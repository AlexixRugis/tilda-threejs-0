<div id="d" class="margin: 3">gnerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<br>
    iiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<br>
    iiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<br>
    inognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignri<br>
    iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiii<br>
    iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiii<br>
    iiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiin<br>
    ognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiii<br>
    iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<br>
    iiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignri<br>
    iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiii<br>
    iiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinogne<br>
    rignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiii<br>
    iiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiino</div>
<canvas id="c"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r120/three.min.js"></script>

<script>
    let camera, scene, renderer, light, cube, sphere;

    const canvas = document.querySelector("#c");

    let lastPointerPos = new THREE.Vector2(0, 0);
    let pointerPos = new THREE.Vector2(0, 0);
    let pointerOffset = new THREE.Vector2(0, 0);

    let isDragging = false;


    const degToRad = Math.PI / 180;
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3(1, 0, 0);
    const forward = new THREE.Vector3(0, 0, 1);

    var loader = new THREE.FileLoader();

    loader.load(
        "./scene.json",
        function (text) {
            setupScene(JSON.parse(text));

            setupRenderer();
            setupCamera();
            setupControls();

            render();
        }
    );

    function setupRenderer() {
        renderer = new THREE.WebGLRenderer({
            antialias: true,
            canvas: canvas,
        });
        renderer.setClearColor(0xffffff, 0);

        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function setupCamera() {
        camera = new THREE.PerspectiveCamera(50.0, window.innerWidth / window.innerHeight, 0.1, 1000);

        camera.position.set(0, 0, 10);

        scene.add(camera);
    }

    function setupScene(text) {
        scene = new THREE.Scene();

        const loader = new THREE.ObjectLoader();
        const loadedScene = loader.parse(text);
        scene = loadedScene;

        scene.background = new THREE.Color(0xffFFFF);

        cube = scene.getObjectByName("Box");
        console.log(cube);
    }

    function setupControls() {
        let onmove = function (e) {

            if (e.preventDefault) e.preventDefault();

            let x = e.pageX || e.changedTouches[0].pageX;
            let y = e.pageY || e.changedTouches[0].pageY;

            pointerPos.set(x, y);
            pointerOffset.subVectors(pointerPos, lastPointerPos);

            cube.rotateOnWorldAxis(up, pointerOffset.x * 0.005);
            cube.rotateOnWorldAxis(right, pointerOffset.y * 0.005);

            lastPointerPos.copy(pointerPos);
        }

        let onend = function (e) {
            document.removeEventListener("pointermove", onmove);
            document.removeEventListener("touchmove", onmove);
            isDragging = false;
        }

        let onstart = function (e) {
            lastPointerPos.set(e.pageX, e.pageY);
            isDragging = true;

            document.addEventListener("pointermove", onmove, { passive: false });
            document.addEventListener("touchmove", onmove, { passive: false });
        }

        document.onpointerdown = onstart;
        document.onpointerup = onend;
        document.ontouchend = onend;
    }

    function render() {

        /*var visibleNormal = new THREE.Vector3();
        var visibleOpacity = -1;

        planes.forEach((plane, i, arr) => {
            var worldNormal = normals[i].clone().transformDirection(cube.matrixWorld).multiplyScalar(10);
            var opacity = worldNormal.clone().normalize().dot(new THREE.Vector3(0, 0, -1));

            opacity = Math.max(Math.min(opacity, 1), 0);

            opacity = Math.pow(opacity, 10);

            if (opacity > visibleOpacity) {
                visibleOpacity = opacity;
                visibleNormal.copy(worldNormal);
            }

            plane.material.opacity = opacity;
            plane.scale.set(opacity, opacity, opacity);
            plane.position.copy(worldNormal);
        });

        if (!isDragging) {
            var offset = new THREE.Vector2(visibleNormal.x, visibleNormal.y).multiplyScalar(0.01);
            var lerpVector = offset.clone().lerp(new THREE.Vector2(0, 0), 0.5);

            cube.rotateOnWorldAxis(up, lerpVector.x);
            cube.rotateOnWorldAxis(right, -lerpVector.y);
        }

        light.position.copy(camera.position);*/

        renderer.render(scene, camera);
        requestAnimationFrame(render);
    }

</script>