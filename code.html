<div id="d" class="margin: 3">gnerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<br>
    iiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<br>
    iiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<br>
    inognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignri<br>
    iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiii<br>
    iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiii<br>
    iiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiin<br>
    ognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiii<br>
    iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<br>
    iiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignri<br>
    iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiii<br>
    iiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinogne<br>
    rignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiii<br>
    iiiiiiiiiiiiiiiiiiiiiiiiinognerignriiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiino</div>
<canvas id="c"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r120/three.min.js"></script>

<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r92/examples/js/controls/OrbitControls.js"></script>

<script>
    let camera, scene, renderer, light, cube, sphere;

    const canvas = document.querySelector("#c");

    let normals = new Array();
    let planes = new Array();

    let lastPointerPos = new THREE.Vector2(0, 0);
    let pointerPos = new THREE.Vector2(0, 0);
    let pointerOffset = new THREE.Vector2(0, 0);

    let isDragging = false;

    let onmove = function (e) {

        if (e.preventDefault) e.preventDefault();

        let x = e.pageX || e.changedTouches[0].pageX;
        let y = e.pageY || e.changedTouches[0].pageY;

        pointerPos.set(x, y);
        pointerOffset.subVectors(pointerPos, lastPointerPos);

        cube.rotateOnWorldAxis(up, pointerOffset.x * 0.005);
        cube.rotateOnWorldAxis(right, -pointerOffset.y * 0.005);

        lastPointerPos.copy(pointerPos);
    }

    let onend = function (e) {
        document.removeEventListener("pointermove", onmove);
        document.removeEventListener("touchmove", onmove);
        isDragging = false;
    }

    let onstart = function (e) {
        lastPointerPos.set(e.pageX, e.pageY);
        isDragging = true;

        document.addEventListener("pointermove", onmove, { passive: false });
        document.addEventListener("touchmove", onmove, { passive: false });
    }

    document.onpointerdown = onstart;
    document.onpointerup = onend;
    document.ontouchend = onend;


    const degToRad = Math.PI / 180;
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3(1, 0, 0);
    const forward = new THREE.Vector3(0, 0, 1);

    function init() {
        renderer = new THREE.WebGLRenderer({
            antialias: true,
            canvas: canvas
        });
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(50.0, window.innerWidth / window.innerHeight, 0.1, 1000);
        scene.add(camera);

        renderer.setClearColor(0xffffff);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
    }

    function initScene() {
        let cubeGeom = new THREE.BoxGeometry(10, 10, 10);
        let material = new THREE.MeshPhongMaterial({ color: 0x00f010, specular: 0x666666, shininess: 10, opacity: 0.5, transparent: true, side: THREE.DoubleSide })

        cube = new THREE.Mesh(cubeGeom, material);
        cube.position.set(0, 0, 0);
        scene.add(cube);

        cube.geometry.faces.forEach((face) => {
            normals.push(face.normal);

            const geometry = new THREE.PlaneGeometry(10, 10);
            const material = new THREE.MeshBasicMaterial({ color: 0xc0c0c0, transparent: true, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(geometry, material);
            planes.push(plane);
            scene.add(plane);
        });

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        hemiLight.color.setHSL(0.6, 1, 0.6);
        hemiLight.groundColor.setHSL(0.095, 1, 0.75);
        hemiLight.position.set(0, 50, 0);
        scene.add(hemiLight);

        light = new THREE.DirectionalLight(0xffffff, 1);
        light.color.setHSL(0.1, 1, 0.95);
        light.position.set(- 1, 1.75, 1);
        light.position.multiplyScalar(30);
        scene.add(light);

        camera.position.set(0, 0, -50);
        camera.lookAt(cube.position);
    }

    function render() {

        var visibleNormal = new THREE.Vector3();
        var visibleOpacity = -1;

        planes.forEach((plane, i, arr) => {
            var worldNormal = normals[i].clone().transformDirection(cube.matrixWorld).multiplyScalar(10);
            var opacity = worldNormal.clone().normalize().dot(new THREE.Vector3(0, 0, -1));

            opacity = Math.max(Math.min(opacity, 1), 0);

            opacity = Math.pow(opacity, 10);

            if (opacity > visibleOpacity) {
                visibleOpacity = opacity;
                visibleNormal.copy(worldNormal);
            }

            plane.material.opacity = opacity;
            plane.scale.set(opacity, opacity, opacity);
            plane.position.copy(worldNormal);
        });

        if (!isDragging) {
            var offset = new THREE.Vector2(visibleNormal.x, visibleNormal.y).multiplyScalar(0.01);
            var lerpVector = offset.clone().lerp(new THREE.Vector2(0, 0), 0.5);

            cube.rotateOnWorldAxis(up, lerpVector.x);
            cube.rotateOnWorldAxis(right, -lerpVector.y);
        }

        light.position.copy(camera.position);

        renderer.render(scene, camera);
        requestAnimationFrame(render);
    }

    init();
    initScene();
    render();

</script>