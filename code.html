<div id="d"></div>
<canvas id="c" style="touch-action: none;"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r120/three.min.js"></script>

<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r92/examples/js/controls/OrbitControls.js"></script>

<script>

    var vp = document.createElement('meta');
    vp.name = "viewport";
    vp.content = "width=device-width; user-scalable=no;";
    document.getElementsByTagName('head')[0].appendChild(vp);

    const debugText = document.querySelector("#d");

    let camera, scene, renderer, light, cube, sphere;

    let normals = new Array();
    let planes = new Array();

    let lastPointerPos = new THREE.Vector2(0, 0);
    let pointerPos = new THREE.Vector2(0, 0);
    let pointerOffset = new THREE.Vector2(0, 0);

    let isDragging = false;

    let onmove = function (e) {

        if (e.preventDefault) e.preventDefault();

        let x = e.pageX || e.changedTouches[0].pageX;
        let y = e.pageY || e.changedTouches[0].pageY;

        pointerPos.set(x, y);
        pointerOffset.subVectors(pointerPos, lastPointerPos);

        cube.rotateOnWorldAxis(up, pointerOffset.x * 0.005);
        cube.rotateOnWorldAxis(right, -pointerOffset.y * 0.005);

        lastPointerPos.copy(pointerPos);
    }

    let onend = function (e) {
        document.removeEventListener("pointermove", onmove);
        document.removeEventListener("touchmove", onmove);
        isDragging = false;
    }

    let onstart = function (e) {
        lastPointerPos.set(e.pageX, e.pageY);
        isDragging = true;

        document.addEventListener("pointermove", onmove, {passive: false});
        document.addEventListener("touchmove", onmove, {passive: false});
    }

    document.onpointerdown = onstart;
    document.onpointerup = onend;
    document.ontouchend = onend;


    const degToRad = Math.PI / 180;
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3(1, 0, 0);
    const forward = new THREE.Vector3(0, 0, 1);

    function init() {
        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(50.0, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer.setClearColor(0xffffff);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
    }

    function initScene() {
        let cubeGeom = new THREE.BoxGeometry(10, 10, 10);
        let material = new THREE.MeshBasicMaterial({

            color: 0x0f0f0f,
            wireframe: true

        });

        cube = new THREE.Mesh(cubeGeom, material);
        cube.position.set(0, 0, 0);
        scene.add(cube);

        cube.geometry.faces.forEach((face) => {
            normals.push(face.normal);

            const geometry = new THREE.PlaneGeometry(10, 10);
            const material = new THREE.MeshBasicMaterial({ color: 0xa00000, transparent: true, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(geometry, material);
            planes.push(plane);
            scene.add(plane);
        });

        light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(-25, 50, 50);
        scene.add(camera);
        camera.add(light);

        camera.position.set(0, 0, -50);
        camera.lookAt(cube.position);
    }

    function render() {

        var visibleNormal = new THREE.Vector3();
        var visibleOpacity = -1;

        planes.forEach((plane, i, arr) => {
            var worldNormal = normals[i].clone().transformDirection(cube.matrixWorld).multiplyScalar(10);
            var opacity = worldNormal.clone().normalize().dot(new THREE.Vector3(0, 0, -1));

            opacity = Math.max(Math.min(opacity, 1), 0);

            opacity = Math.pow(opacity, 10);

            if (opacity > visibleOpacity) {
                visibleOpacity = opacity;
                visibleNormal.copy(worldNormal);
            }

            plane.material.opacity = opacity;
            plane.position.copy(worldNormal);
        });

        if (!isDragging) {
            var offset = new THREE.Vector2(visibleNormal.x, visibleNormal.y).multiplyScalar(0.01);
            var lerpVector = offset.clone().lerp(new THREE.Vector2(0, 0), 0.5);

            console.log("ss");

            cube.rotateOnWorldAxis(up, lerpVector.x);
            cube.rotateOnWorldAxis(right, -lerpVector.y);
        }

        renderer.render(scene, camera);
        requestAnimationFrame(render);
    }

    init();
    initScene();
    render();

</script>